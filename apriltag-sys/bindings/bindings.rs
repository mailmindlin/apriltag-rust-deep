/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
#[doc = " Defines a matrix structure for holding double-precision values with\n data in row-major order (i.e. index = row*ncols + col).\n\n nrows and ncols are 1-based counts with the exception that a scalar (non-matrix)\n   is represented with nrows=0 and/or ncols=0."]
#[repr(C)]
#[derive(Debug)]
pub struct matd_t {
    pub nrows: ::std::os::raw::c_uint,
    pub ncols: ::std::os::raw::c_uint,
    pub data: __IncompleteArrayField<f64>,
}
#[test]
fn bindgen_test_layout_matd_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_t>(),
        8usize,
        concat!("Size of: ", stringify!(matd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncols) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(ncols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n to zero. It is the caller's responsibility to call matd_destroy() on the\n returned matrix."]
    pub fn matd_create(rows: ::std::os::raw::c_int, cols: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n using the supplied array of data, which must contain at least rows*cols elements,\n arranged in row-major order (i.e. index = row*ncols + col). It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_data(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f64,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n using the supplied array of float data, which must contain at least rows*cols elements,\n arranged in row-major order (i.e. index = row*ncols + col). It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_dataf(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f32,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a square identity matrix with the given number of rows (and\n therefore columns), or a scalar with value 1 in the case where dim=0.\n It is the caller's responsibility to call matd_destroy() on the\n returned matrix."]
    pub fn matd_identity(dim: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a scalar with the supplied value 'v'. It is the caller's responsibility\n to call matd_destroy() on the returned matrix.\n\n NOTE: Scalars are different than 1x1 matrices (implementation note:\n they are encoded as 0x0 matrices). For example: for matrices A*B, A\n and B must both have specific dimensions. However, if A is a\n scalar, there are no restrictions on the size of B."]
    pub fn matd_create_scalar(v: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Retrieves the cell value for matrix 'm' at the given zero-based row and column index.\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get(
        m: *const matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the matrix cell at the given zero-based row and\n column index. Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put(
        m: *mut matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    #[doc = " Retrieves the scalar value of the given element ('m' must be a scalar).\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get_scalar(m: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the supplied scalar element ('m' must be a scalar).\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put_scalar(m: *mut matd_t, value: f64);
}
extern "C" {
    #[doc = " Creates an exact copy of the supplied matrix 'm'. It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_copy(m: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a copy of a subset of the supplied matrix 'a'. The subset will include\n rows 'r0' through 'r1', inclusive ('r1' >= 'r0'), and columns 'c0' through 'c1',\n inclusive ('c1' >= 'c0'). All parameters are zero-based (i.e. matd_select(a, 0, 0, 0, 0)\n will return only the first cell). Cannot be used on scalars or to extend\n beyond the number of rows/columns of 'a'. It is the caller's  responsibility to\n call matd_destroy() on the returned matrix."]
    pub fn matd_select(
        a: *const matd_t,
        r0: ::std::os::raw::c_int,
        r1: ::std::os::raw::c_int,
        c0: ::std::os::raw::c_int,
        c1: ::std::os::raw::c_int,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Prints the supplied matrix 'm' to standard output by applying the supplied\n printf format specifier 'fmt' for each individual element. Each row will\n be printed on a separate newline."]
    pub fn matd_print(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Prints the transpose of the supplied matrix 'm' to standard output by applying\n the supplied printf format specifier 'fmt' for each individual element. Each\n row will be printed on a separate newline."]
    pub fn matd_print_transpose(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Adds the two supplied matrices together, cell-by-cell, and returns the results\n as a new matrix of the same dimensions. The supplied matrices must have\n identical dimensions.  It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_add(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Adds the values of 'b' to matrix 'a', cell-by-cell, and overwrites the\n contents of 'a' with the results. The supplied matrices must have\n identical dimensions."]
    pub fn matd_add_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Subtracts matrix 'b' from matrix 'a', cell-by-cell, and returns the results\n as a new matrix of the same dimensions. The supplied matrices must have\n identical dimensions.  It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_subtract(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Subtracts the values of 'b' from matrix 'a', cell-by-cell, and overwrites the\n contents of 'a' with the results. The supplied matrices must have\n identical dimensions."]
    pub fn matd_subtract_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and\n returns the result as a new matrix of the same dimensions. It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_scale(a: *const matd_t, s: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and\n overwrites the contents of 'a' with the results."]
    pub fn matd_scale_inplace(a: *mut matd_t, s: f64);
}
extern "C" {
    #[doc = " Multiplies the two supplied matrices together (matrix product), and returns the\n results as a new matrix. The supplied matrices must have dimensions such that\n columns(a) = rows(b). The returned matrix will have a row count of rows(a)\n and a column count of columns(b). It is the caller's responsibility to call\n matd_destroy() on the returned matrix."]
    pub fn matd_multiply(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a matrix which is the transpose of the supplied matrix 'a'. It is the\n caller's responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_transpose(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the determinant of the supplied matrix 'a'."]
    pub fn matd_det(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Attempts to compute an inverse of the supplied matrix 'a' and return it as\n a new matrix. This is strictly only possible if the determinant of 'a' is\n non-zero (matd_det(a) != 0).\n\n If the determinant is zero, NULL is returned. It is otherwise the\n caller's responsibility to cope with the results caused by poorly\n conditioned matrices. (E.g.., if such a situation is likely to arise, compute\n the pseudo-inverse from the SVD.)"]
    pub fn matd_inverse(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the magnitude of the supplied matrix 'a'."]
    pub fn matd_vec_mag(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the magnitude of the distance between the points represented by\n matrices 'a' and 'b'. Both 'a' and 'b' must be vectors and have the same\n dimension (although one may be a row vector and one may be a column vector)."]
    pub fn matd_vec_dist(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Same as matd_vec_dist, but only uses the first 'n' terms to compute distance"]
    pub fn matd_vec_dist_n(a: *const matd_t, b: *const matd_t, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Calculates the dot product of two vectors. Both 'a' and 'b' must be vectors\n and have the same dimension (although one may be a row vector and one may be\n a column vector)."]
    pub fn matd_vec_dot_product(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the normalization of the supplied vector 'a' (i.e. a unit vector\n of the same dimension and orientation as 'a' with a magnitude of 1) and returns\n it as a new vector. 'a' must be a vector of any dimension and must have a\n non-zero magnitude. It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_vec_normalize(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the cross product of supplied matrices 'a' and 'b' (i.e. a x b)\n and returns it as a new matrix. Both 'a' and 'b' must be vectors of dimension\n 3, but can be either row or column vectors. It is the caller's responsibility\n to call matd_destroy() on the returned matrix."]
    pub fn matd_crossproduct(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_err_inf(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Creates a new matrix by applying a series of matrix operations, as expressed\n in 'expr', to the supplied list of matrices. Each matrix to be operated upon\n must be represented in the expression by a separate matrix placeholder, 'M',\n and there must be one matrix supplied as an argument for each matrix\n placeholder in the expression. All rules and caveats of the corresponding\n matrix operations apply to the operated-on matrices. It is the caller's\n responsibility to call matd_destroy() on the returned matrix.\n\n Available operators (in order of increasing precedence):\n   M+M   add two matrices together\n   M-M   subtract one matrix from another\n   M*M   multiply two matrices together (matrix product)\n   MM    multiply two matrices together (matrix product)\n   -M    negate a matrix\n   M^-1  take the inverse of a matrix\n   M'    take the transpose of a matrix\n\n Expressions can be combined together and grouped by enclosing them in\n parenthesis, i.e.:\n   -M(M+M+M)-(M*M)^-1\n\n Scalar values can be generated on-the-fly, i.e.:\n   M*2.2  scales M by 2.2\n   -2+M   adds -2 to all elements of M\n\n All whitespace in the expression is ignored."]
    pub fn matd_op(expr: *const ::std::os::raw::c_char, ...) -> *mut matd_t;
}
extern "C" {
    #[doc = " Frees the memory associated with matrix 'm', being the result of an earlier\n call to a matd_*() function, after which 'm' will no longer be usable."]
    pub fn matd_destroy(m: *mut matd_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_svd_t {
    pub U: *mut matd_t,
    pub S: *mut matd_t,
    pub V: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_svd_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_svd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_svd_t>(),
        24usize,
        concat!("Size of: ", stringify!(matd_svd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_svd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_svd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(S)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(V)
        )
    );
}
extern "C" {
    #[doc = " Compute a complete SVD of a matrix. The SVD exists for all\n matrices. For a matrix MxN, we will have:\n\n A = U*S*V'\n\n where A is MxN, U is MxM (and is an orthonormal basis), S is MxN\n (and is diagonal up to machine precision), and V is NxN (and is an\n orthonormal basis).\n\n The caller is responsible for destroying U, S, and V."]
    pub fn matd_svd(A: *mut matd_t) -> matd_svd_t;
}
extern "C" {
    pub fn matd_svd_flags(A: *mut matd_t, flags: ::std::os::raw::c_int) -> matd_svd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_plu_t {
    pub singular: ::std::os::raw::c_int,
    pub piv: *mut ::std::os::raw::c_uint,
    pub pivsign: ::std::os::raw::c_int,
    pub lu: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_plu_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_plu_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_plu_t>(),
        32usize,
        concat!("Size of: ", stringify!(matd_plu_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_plu_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_plu_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singular) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(singular)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(piv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pivsign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(pivsign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(lu)
        )
    );
}
extern "C" {
    pub fn matd_plu(a: *const matd_t) -> *mut matd_plu_t;
}
extern "C" {
    pub fn matd_plu_destroy(mlu: *mut matd_plu_t);
}
extern "C" {
    pub fn matd_plu_det(lu: *const matd_plu_t) -> f64;
}
extern "C" {
    pub fn matd_plu_p(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_l(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_u(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_solve(mlu: *const matd_plu_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_solve(A: *mut matd_t, b: *mut matd_t) -> *mut matd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_chol_t {
    pub is_spd: ::std::os::raw::c_int,
    pub u: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_chol_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_chol_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_chol_t>(),
        16usize,
        concat!("Size of: ", stringify!(matd_chol_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_chol_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_chol_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_spd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(is_spd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn matd_chol(A: *mut matd_t) -> *mut matd_chol_t;
}
extern "C" {
    pub fn matd_chol_solve(chol: *const matd_chol_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_chol_destroy(chol: *mut matd_chol_t);
}
extern "C" {
    pub fn matd_chol_inverse(a: *mut matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_ltransposetriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_ltriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_utriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_max(m: *mut matd_t) -> f64;
}
pub type image_u8_t = image_u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x3_t = image_u8x3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x3 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x3() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8x3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8x3>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x3))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x3>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x4_t = image_u8x4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x4 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x4() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8x4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8x4>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x4))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x4>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_f32_t = image_f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_f32 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut f32,
}
#[test]
fn bindgen_test_layout_image_f32() {
    const UNINIT: ::std::mem::MaybeUninit<image_f32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_f32>(),
        24usize,
        concat!("Size of: ", stringify!(image_f32))
    );
    assert_eq!(
        ::std::mem::align_of::<image_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(image_f32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8_lut_t = image_u8_lut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8_lut {
    pub scale: f32,
    pub nvalues: ::std::os::raw::c_int,
    pub values: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8_lut() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8_lut> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8_lut>(),
        16usize,
        concat!("Size of: ", stringify!(image_u8_lut))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8_lut>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8_lut))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvalues) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(nvalues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(values)
        )
    );
}
extern "C" {
    pub fn image_u8_create_stride(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        stride: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_alignment(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_f32(fim: *mut image_f32_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm(path: *const ::std::os::raw::c_char) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm_alignment(
        path: *const ::std::os::raw::c_char,
        alignment: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_copy(in_: *const image_u8_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_draw_line(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        v: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_circle(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_annulus(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r0: f32,
        r1: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_fill_line_max(
        im: *mut image_u8_t,
        lut: *const image_u8_lut_t,
        xy0: *const f32,
        xy1: *const f32,
    );
}
extern "C" {
    pub fn image_u8_clear(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_darken(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_convolve_2D(im: *mut image_u8_t, k: *const u8, ksz: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_gaussian_blur(im: *mut image_u8_t, sigma: f64, k: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_decimate(im: *mut image_u8_t, factor: f32) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_destroy(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_write_pnm(
        im: *const image_u8_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn image_u8_rotate(in_: *const image_u8_t, rad: f64, pad: u8) -> *mut image_u8_t;
}
#[doc = " Defines a structure which acts as a resize-able array ala Java's ArrayList."]
pub type zarray_t = zarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zarray {
    pub el_sz: usize,
    pub size: ::std::os::raw::c_int,
    pub alloc: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_zarray() {
    const UNINIT: ::std::mem::MaybeUninit<zarray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zarray>(),
        24usize,
        concat!("Size of: ", stringify!(zarray))
    );
    assert_eq!(
        ::std::mem::align_of::<zarray>(),
        8usize,
        concat!("Alignment of ", stringify!(zarray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(el_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Creates and returns a variable array structure capable of holding elements of\n the specified size. It is the caller's responsibility to call zarray_destroy()\n on the returned array when it is no longer needed."]
    pub fn zarray_create(el_sz: usize) -> *mut zarray_t;
}
extern "C" {
    #[doc = " Frees all resources associated with the variable array structure which was\n created by zarray_create(). After calling, 'za' will no longer be valid for storage."]
    pub fn zarray_destroy(za: *mut zarray_t);
}
extern "C" {
    #[doc = " Allocates enough internal storage in the supplied variable array structure to\n guarantee that the supplied number of elements (capacity) can be safely stored."]
    pub fn zarray_ensure_capacity(za: *mut zarray_t, capacity: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Calls the supplied function for every element in the array in index order.\n HOWEVER values are passed to the function, not pointers to values. In the\n case where the zarray stores object pointers, zarray_vmap allows you to\n pass in the object's destroy function (or free) directly. Can only be used\n with zarray's which contain pointer data. The map function should have the\n following format:\n\n void map_function(element_type *element)"]
    pub fn zarray_vmap(za: *mut zarray_t, f: ::std::option::Option<unsafe extern "C" fn()>);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workerpool {
    _unused: [u8; 0],
}
pub type workerpool_t = workerpool;
pub type timeprofile_t = timeprofile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeprofile {
    pub utime: i64,
    pub stamps: *mut zarray_t,
}
#[test]
fn bindgen_test_layout_timeprofile() {
    const UNINIT: ::std::mem::MaybeUninit<timeprofile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeprofile>(),
        16usize,
        concat!("Size of: ", stringify!(timeprofile))
    );
    assert_eq!(
        ::std::mem::align_of::<timeprofile>(),
        8usize,
        concat!("Alignment of ", stringify!(timeprofile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(stamps)
        )
    );
}
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quad {
    pub p: [[f32; 2usize]; 4usize],
    pub reversed_border: bool,
    pub H: *mut matd_t,
    pub Hinv: *mut matd_t,
}
#[test]
fn bindgen_test_layout_quad() {
    const UNINIT: ::std::mem::MaybeUninit<quad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<quad>(),
        56usize,
        concat!("Size of: ", stringify!(quad))
    );
    assert_eq!(
        ::std::mem::align_of::<quad>(),
        8usize,
        concat!("Alignment of ", stringify!(quad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(quad), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reversed_border) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quad),
            "::",
            stringify!(reversed_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(quad), "::", stringify!(H))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hinv) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quad),
            "::",
            stringify!(Hinv)
        )
    );
}
pub type apriltag_family_t = apriltag_family;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_family {
    pub ncodes: u32,
    pub codes: *mut u64,
    pub width_at_border: ::std::os::raw::c_int,
    pub total_width: ::std::os::raw::c_int,
    pub reversed_border: bool,
    pub nbits: u32,
    pub bit_x: *mut u32,
    pub bit_y: *mut u32,
    pub h: u32,
    pub name: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_apriltag_family() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_family> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_family>(),
        72usize,
        concat!("Size of: ", stringify!(apriltag_family))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_family>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_family))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(ncodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(codes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_at_border) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(width_at_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(total_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reversed_border) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(reversed_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_y) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_quad_thresh_params {
    pub min_cluster_pixels: ::std::os::raw::c_int,
    pub max_nmaxima: ::std::os::raw::c_int,
    pub critical_rad: f32,
    pub cos_critical_rad: f32,
    pub max_line_fit_mse: f32,
    pub min_white_black_diff: ::std::os::raw::c_int,
    pub deglitch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apriltag_quad_thresh_params() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_quad_thresh_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_quad_thresh_params>(),
        28usize,
        concat!("Size of: ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_quad_thresh_params>(),
        4usize,
        concat!("Alignment of ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_cluster_pixels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_cluster_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_nmaxima) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_nmaxima)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).critical_rad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(critical_rad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cos_critical_rad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(cos_critical_rad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_line_fit_mse) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_line_fit_mse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_white_black_diff) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_white_black_diff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deglitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(deglitch)
        )
    );
}
pub type apriltag_detector_t = apriltag_detector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detector {
    pub nthreads: ::std::os::raw::c_int,
    pub quad_decimate: f32,
    pub quad_sigma: f32,
    pub refine_edges: bool,
    pub decode_sharpening: f64,
    pub debug: bool,
    pub qtp: apriltag_quad_thresh_params,
    pub tp: *mut timeprofile_t,
    pub nedges: u32,
    pub nsegments: u32,
    pub nquads: u32,
    pub tag_families: *mut zarray_t,
    pub wp: *mut workerpool_t,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_apriltag_detector() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detector>(),
        160usize,
        concat!("Size of: ", stringify!(apriltag_detector))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detector>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthreads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quad_decimate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_decimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quad_sigma) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_sigma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refine_edges) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(refine_edges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_sharpening) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(decode_sharpening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qtp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(qtp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nedges) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nedges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsegments) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nsegments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nquads) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nquads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_families) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tag_families)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wp) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(mutex)
        )
    );
}
pub type apriltag_detection_t = apriltag_detection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection {
    pub family: *mut apriltag_family_t,
    pub id: ::std::os::raw::c_int,
    pub hamming: ::std::os::raw::c_int,
    pub decision_margin: f32,
    pub H: *mut matd_t,
    pub c: [f64; 2usize],
    pub p: [[f64; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_apriltag_detection() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection>(),
        112usize,
        concat!("Size of: ", stringify!(apriltag_detection))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hamming) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(hamming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decision_margin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(decision_margin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(p)
        )
    );
}
extern "C" {
    pub fn apriltag_detector_create() -> *mut apriltag_detector_t;
}
extern "C" {
    pub fn apriltag_detector_add_family_bits(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
        bits_corrected: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn apriltag_detector_remove_family(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
    );
}
extern "C" {
    pub fn apriltag_detector_clear_families(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_destroy(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_detect(
        td: *mut apriltag_detector_t,
        im_orig: *mut image_u8_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn apriltag_detection_destroy(det: *mut apriltag_detection_t);
}
extern "C" {
    pub fn apriltag_detections_destroy(detections: *mut zarray_t);
}
extern "C" {
    pub fn apriltag_to_image(
        fam: *mut apriltag_family_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection_info_t {
    pub det: *mut apriltag_detection_t,
    pub tagsize: f64,
    pub fx: f64,
    pub fy: f64,
    pub cx: f64,
    pub cy: f64,
}
#[test]
fn bindgen_test_layout_apriltag_detection_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detection_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).det) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(det)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tagsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(tagsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cy)
        )
    );
}
#[doc = " This struct holds the transformation from the camera optical frame to\n the April tag frame. The pose refers to the position of the tag within\n the camera frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_pose_t {
    pub R: *mut matd_t,
    pub t: *mut matd_t,
}
#[test]
fn bindgen_test_layout_apriltag_pose_t() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_pose_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_pose_t>(),
        16usize,
        concat!("Size of: ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_pose_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(t)
        )
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag using the homography method described in [1].\n @outparam pose"]
    pub fn estimate_pose_for_tag_homography(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag. This returns one or two possible poses for the\n tag, along with the object-space error of each.\n\n This uses the homography method described in [1] for the initial estimate.\n Then Orthogonal Iteration [2] is used to refine this estimate. Then [3] is\n used to find a potential second local minima and Orthogonal Iteration is\n used to refine this second estimate.\n\n [1]: E. Olson, “Apriltag: A robust and flexible visual fiducial system,” in\n      2011 IEEE International Conference on Robotics and Automation,\n      May 2011, pp. 3400–3407.\n [2]: Lu, G. D. Hager and E. Mjolsness, \"Fast and globally convergent pose\n      estimation from video images,\" in IEEE Transactions on Pattern Analysis\n      and Machine Intelligence, vol. 22, no. 6, pp. 610-622, June 2000.\n      doi: 10.1109/34.862199\n [3]: Schweighofer and A. Pinz, \"Robust Pose Estimation from a Planar Target,\"\n      in IEEE Transactions on Pattern Analysis and Machine Intelligence,\n      vol. 28, no. 12, pp. 2024-2030, Dec. 2006.  doi: 10.1109/TPAMI.2006.252\n\n @outparam err1, pose1, err2, pose2"]
    pub fn estimate_tag_pose_orthogonal_iteration(
        info: *mut apriltag_detection_info_t,
        err1: *mut f64,
        pose1: *mut apriltag_pose_t,
        err2: *mut f64,
        pose2: *mut apriltag_pose_t,
        nIters: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Estimate tag pose.\n This method is an easier to use interface to estimate_tag_pose_orthogonal_iteration.\n\n @outparam pose\n @return Object-space error of returned pose."]
    pub fn estimate_tag_pose(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    ) -> f64;
}
extern "C" {
    pub fn tag16h5_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag16h5_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag25h9_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag25h9_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag36h10_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag36h10_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag36h11_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag36h11_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle21h7_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle21h7_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle49h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle49h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCustom48h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCustom48h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard41h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard41h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard52h13_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard52h13_destroy(tf: *mut apriltag_family_t);
}
pub type unionfind_t = unionfind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unionfind {
    pub maxid: u32,
    pub data: *mut ufrec,
}
#[test]
fn bindgen_test_layout_unionfind() {
    const UNINIT: ::std::mem::MaybeUninit<unionfind> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unionfind>(),
        16usize,
        concat!("Size of: ", stringify!(unionfind))
    );
    assert_eq!(
        ::std::mem::align_of::<unionfind>(),
        8usize,
        concat!("Alignment of ", stringify!(unionfind))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unionfind),
            "::",
            stringify!(maxid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unionfind),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ufrec {
    pub parent: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_ufrec() {
    const UNINIT: ::std::mem::MaybeUninit<ufrec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ufrec>(),
        8usize,
        concat!("Size of: ", stringify!(ufrec))
    );
    assert_eq!(
        ::std::mem::align_of::<ufrec>(),
        4usize,
        concat!("Alignment of ", stringify!(ufrec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ufrec),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ufrec),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn homography_compute(
        correspondences: *mut zarray_t,
        flags: ::std::os::raw::c_int,
    ) -> *mut matd_t;
}
extern "C" {
    pub fn homography_project(H: *const matd_t, x: f64, y: f64, ox: *mut f64, oy: *mut f64);
}
extern "C" {
    pub fn homography_to_pose(H: *const matd_t, fx: f64, fy: f64, cx: f64, cy: f64) -> *mut matd_t;
}
extern "C" {
    pub fn homography_to_model_view(
        H: *const matd_t,
        F: f64,
        G: f64,
        A: f64,
        B: f64,
        C: f64,
        D: f64,
    ) -> *mut matd_t;
}
extern "C" {
    pub fn apriltag_quad_thresh(td: *mut apriltag_detector_t, im: *mut image_u8_t)
        -> *mut zarray_t;
}
extern "C" {
    pub fn connected_components(
        td: *mut apriltag_detector_t,
        threshim: *mut image_u8_t,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        ts: ::std::os::raw::c_int,
    ) -> *mut unionfind_t;
}
extern "C" {
    pub fn do_gradient_clusters(
        threshim: *mut image_u8_t,
        ts: ::std::os::raw::c_int,
        y0: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        nclustermap: ::std::os::raw::c_int,
        uf: *mut unionfind_t,
        clusters: *mut zarray_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn merge_clusters(c1: *mut zarray_t, c2: *mut zarray_t) -> *mut zarray_t;
}
extern "C" {
    pub fn gradient_clusters(
        td: *mut apriltag_detector_t,
        threshim: *mut image_u8_t,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        ts: ::std::os::raw::c_int,
        uf: *mut unionfind_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn fit_quads(
        td: *mut apriltag_detector_t,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        clusters: *mut zarray_t,
        im: *mut image_u8_t,
    ) -> *mut zarray_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt {
    pub x: u16,
    pub y: u16,
    pub gx: i16,
    pub gy: i16,
    pub slope: f32,
}
#[test]
fn bindgen_test_layout_pt() {
    const UNINIT: ::std::mem::MaybeUninit<pt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pt>(),
        12usize,
        concat!("Size of: ", stringify!(pt))
    );
    assert_eq!(
        ::std::mem::align_of::<pt>(),
        4usize,
        concat!("Alignment of ", stringify!(pt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pt), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(pt), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gx) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(pt), "::", stringify!(gx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gy) as usize - ptr as usize },
        6usize,
        concat!("Offset of field: ", stringify!(pt), "::", stringify!(gy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slope) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(pt), "::", stringify!(slope))
    );
}
extern "C" {
    pub fn fit_quad(
        td: *mut apriltag_detector_t,
        im: *mut image_u8_t,
        cluster: *mut zarray_t,
        quad: *mut quad,
        tag_width: ::std::os::raw::c_int,
        normal_border: bool,
        reversed_border: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct line_fit_pt {
    pub Mx: f64,
    pub My: f64,
    pub Mxx: f64,
    pub Myy: f64,
    pub Mxy: f64,
    pub W: f64,
}
#[test]
fn bindgen_test_layout_line_fit_pt() {
    const UNINIT: ::std::mem::MaybeUninit<line_fit_pt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<line_fit_pt>(),
        48usize,
        concat!("Size of: ", stringify!(line_fit_pt))
    );
    assert_eq!(
        ::std::mem::align_of::<line_fit_pt>(),
        8usize,
        concat!("Alignment of ", stringify!(line_fit_pt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(Mx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).My) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(My)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mxx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(Mxx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Myy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(Myy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mxy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(Mxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(line_fit_pt),
            "::",
            stringify!(W)
        )
    );
}
extern "C" {
    pub fn fit_line(
        lfps: *mut line_fit_pt,
        sz: ::std::os::raw::c_int,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        lineparm: *mut f64,
        err: *mut f64,
        mse: *mut f64,
    );
}
extern "C" {
    pub fn compute_lfps(
        sz: ::std::os::raw::c_int,
        cluster: *mut zarray_t,
        im: *mut image_u8_t,
    ) -> *mut line_fit_pt;
}
extern "C" {
    pub fn refine_edges(td: *mut apriltag_detector_t, im_orig: *mut image_u8_t, quad: *mut quad);
}
extern "C" {
    pub fn quad_update_homographies(quad: *mut quad) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quick_decode_entry {
    pub rcode: u64,
    pub id: u16,
    pub hamming: u8,
    pub rotation: u8,
}
#[test]
fn bindgen_test_layout_quick_decode_entry() {
    const UNINIT: ::std::mem::MaybeUninit<quick_decode_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<quick_decode_entry>(),
        16usize,
        concat!("Size of: ", stringify!(quick_decode_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<quick_decode_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(quick_decode_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quick_decode_entry),
            "::",
            stringify!(rcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quick_decode_entry),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hamming) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(quick_decode_entry),
            "::",
            stringify!(hamming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(quick_decode_entry),
            "::",
            stringify!(rotation)
        )
    );
}
extern "C" {
    pub fn quad_decode(
        td: *mut apriltag_detector_t,
        family: *mut apriltag_family_t,
        im: *mut image_u8_t,
        quad: *mut quad,
        entry: *mut quick_decode_entry,
        im_samples: *mut image_u8_t,
    ) -> f32;
}
extern "C" {
    pub fn quick_decode_init(family: *mut apriltag_family_t, maxhamming: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_decode_uninit(fam: *mut apriltag_family_t);
}
extern "C" {
    pub fn quad_segment_maxima(
        td: *mut apriltag_detector_t,
        cluster: *mut zarray_t,
        lfps: *mut line_fit_pt,
        indices: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsort(pts: *mut pt, sz: ::std::os::raw::c_int);
}
